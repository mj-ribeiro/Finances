}
return (H_tr)
}
H_trf(x1)
#----------------------------------------- w tilde  (Proposition 1)
w_tilf = function(x1){
w_til = matrix(0, i, r)
for (c in 1:i){
for (j in 1:r){
w_til[c, j] = ( (1 - x1[c, j, 1]) / ( (1 + x1[c, j, 2]) ** eta) ) * H_tr[j]**varphi * x1[c, j, 3] * s[c]**phi[c] * (1 - s[c]) ** ( (1- eta) /beta )
}
}
return (w_til)
}
H_tr = runif(4)
#--------------------------- w_r
w_rf = function(){
w_r = w_til**theta
w_r = colSums(w_r)
return(w_r)
}
w_r = w_rf()
#------------------------------------------ p_ir  (eq 19)
p_irf = function(){
p_ir = matrix(0, i, r)
for (c in 1:i){
for (j in 1:r){
p_ir[c, j] = (( w_til[c, j] )) ** theta / w_r[c]
}
}
p_i = colSums(p_ir)
return (p_ir)
}
p_irf()
(-2)^0.44
#---------------------------------------  W (eq 27)
Wf = function(x1){
W = matrix(0, i, r)
for (c in 1:i){
for (j in 1:r){
W[c, j] = ((1 - s[c])**(-1/beta))/( 1 - x1[c, j, 1] )*gamma1*eta*(w_r[j])**(1/(theta*(1 - eta)))
}
}
return (W)
}
#--------- Simulated data
W_t = rbind(c(0.1, 0.42, 0.33, 0.12), c(0.99, 0.22, 0.154, 0.654))
p_t = rbind(c(0.122, 0.12, 0.132, 0.109), c(0.212, 0.453, 0.3524, 0.114))
#--------------------- OBJECTIVE FUNCTION
p_ir = p_irf()
w = runif(i*r, 0, 1)
tau_w =  runif(i*r, -1, 1)
tau_h = runif(i*r, -1, 1)
x1 = array( c(tau_w, tau_h, w), dim = c(i, r, 3))*0.5
obj(x1)
obj = function(x1){
s = sf()
h_til = h_tilf()
w_til = w_tilf(x1)
w_r = w_rf()
p_ir = p_irf()
#H_tr = H_trf(x1)
W = Wf(x1)
f1 = matrix(0, i, r)
f2 = matrix(0, i, r)
for (c in 1:i){
for (j in 1:r){
f1[c, j] = ( (W[c, j] - W_t[c, j]) / W_t[c, j] ) ** 2
f2[c, j] = ( (p_ir[c, j] - p_t[c, j])  /  p_t[c, j] ) ** 2
}
}
d1 = sum(f1)
d2 = sum(f2)
D = d1 + d2
return(D)
}
obj(x1)
#-------------------------- Solve
library('Rsolnp')
library('optimx')
res = optim(x1, obj)
w_til = w_tilf(x1)
w_rf = function(){
w_r = w_til**theta
w_r = colSums(w_r)
return(w_r)
}
w_rf()
res = optim(x1, obj)
res = optim(x1, obj)
x2 = rbind(tau_w, tau_h, w)
x2
x2
H_trf = function(x1){
s = sf()
P = matrix(0, 1, r)
Ti = matrix(0, i, r)
S = matrix(0, i, 1)
N = matrix(0, i, r)
H = matrix(0, i, r)
for (c in 1:i){
for (j in 1:r){
S[c] = ( s[c]**phi[c]*eta**eta ) ** kappa
P[j] = ( ( ( 1 - colSums(x1[1, ])[j] ) / ( ( 1 + colSums(x1[2, ])[j] )**eta) ) * ( colSums(x1[3, ])[j] ) ) ** (theta - kappa)
Ti[c, j] = ( ( 1 - x1[1, j] ) * x1[3, j] ) ** ( theta - kappa +kappa*eta)
N[c, j] = ( 1 + x1[c, j, 2]) ** (eta*theta)
H[c, j] = ( ( Ti[c, j] * S[c] * gamma1 ) / ( N[c, j] * P[j]) ** (1/(1-varphi*kappa)))
H_tr = H[i-1, ]
}
}
return (H_tr)
}
H_trf(x2)
x2 = rbind(tau_w, tau_h, w)
x2
x2 = matrix(tau_w, tau_h, w, nrow = i*3, ncol = r)
x2 = matrix(c(tau_w, tau_h, w), nrow = i*3, ncol = r)
x2
w = runif(i*r, 0, 1)
w
x2 = matrix(c(tau_w, tau_h, w), nrow = i*3, ncol = r)
x2
w = rbind( runif(i*r, 0, 1), nrow=i, ncol=r )
w = rbind( runif(i*r, 0, 1), nrow=i, ncol=r )
tau_w =  rbind(runif(i*r, -1, 1), nrow=i, ncol=r )
tau_h = rbind(runif(i*r, -1, 1), nrow=i, ncol=r )
x2 = matrix(c(tau_w, tau_h, w), nrow = i*3, ncol = r)
x2
w
w = matrix( runif(i*r, 0, 1), nrow=i, ncol=r )
w
w = matrix( runif(i*r, 0, 1), nrow=i, ncol=r )
tau_w =  matrix(runif(i*r, -1, 1), nrow=i, ncol=r )
tau_h = matrix(runif(i*r, -1, 1), nrow=i, ncol=r )
x2 = matrix(c(tau_w, tau_h, w), nrow = i*3, ncol = r)
x2
w
x2 = rbind(c(tau_w, tau_h, w))
x2
install.packages('caRamel')
library('caRamel')
res = caRamel(x1, obj)
View(res)
res = caRamel(x1, func=obj)
res = caRamel(nobj=3, x1, func=obj)
res = caRamel(nobj=3, nvar=x1, func=obj)
res = caRamel(nobj=1, nvar=3, func=obj)
res = caRamel(nobj=2, nvar=3, func=obj)
res = polyopt(nobj=2, nvar=3, func=obj)
res = polyopt(x1, obj)
res = polyopt(x1, obj, gr=NULL)
df = data.frame(tau_w, tau_h, w)
df[1]
df[2]
df[3]
View(df)
rm(df)
w = runif(i*r, 0, 1)
tau_w =  runif(i*r, -1, 1)
tau_h = runif(i*r, -1, 1)
df = data.frame(tau_w, tau_h, w)
df[3]
df[1]
View(df)
View(df)
res = polyopt(x1, obj, gr=NULL)
res = solnp(x1,      #starting values
obj,   #function to optimise
LB=c(rep(0, length(x1))), #lower bound for parameters i.e. greater than zero
UB=c(rep(1, length(x1)))) #upper bound for parameters i.e less than one
obj(x1)
w_r = w_rf()
obj(x1)
res = solnp(x1,      #starting values
obj,   #function to optimise
LB=c(rep(0, length(x1))), #lower bound for parameters i.e. greater than zero
UB=c(rep(1, length(x1)))) #upper bound for parameters i.e less than one
res = optim(x1,      #starting values
obj)   #function to optimise
knitr::opts_chunk$set(echo = FALSE)
x = rnorm(1000, 0, 1)
hist(x, breaks = 25, col = 'lightgreen)
x = rnorm(1000, 0, 1)
hist(x, breaks = 25, col = 'lightgreen')
knitr::opts_chunk$set(echo = FALSE)
x = rnorm(1000)
y = rnorm(1000)
reg = lm(x~y)
x = rnorm(1000)
y = rnorm(1000)
reg = lm(x~y)
x = rnorm(1000)
y = rnorm(1000)
reg = lm(x~y)
x = rnorm(1000)
y = rnorm(1000)
reg = lm(x~y)
knitr::opts_chunk$set(echo = FALSE)
x = rnorm(1000)
y = rnorm(1000)
reg = lm(x~y)
summary(reg)
seed(1)
set.seed(1)
x = rnorm(1000)
y = rnorm(1000)
reg = lm(x~y)
summary(reg)
knitr::opts_chunk$set(echo = FALSE)
set.seed(1)
x = rnorm(1000)
y = rnorm(1000)
reg = lm(x~y)
#summary(reg)
knitr::kable(reg)
View(reg)
set.seed(1)
x = rnorm(1000)
y = rnorm(1000)
reg = lm(x~y)
knitr::kable(summary(reg))
set.seed(1)
x = rnorm(1000)
y = rnorm(1000)
reg = lm(x~y)
summary(reg)
setwd("C:/Users/user/Downloads/ML_work/Algorithm")
df = read.csv('naive_base.csv')
df = read.csv('naive_base.csv')
head(df)
df = read.csv('naive_base.csv')
df$garantias =NULL
df$renda =NULL
head(df)
df = read.csv('naive_base.csv')
df$garantias =NULL
df$renda =NULL
knitr::kable(head(df))
df = read.csv('naive_base.csv')
df$garantias =NULL
df$renda =NULL
knitr::kable(head(df))
---
title: "Naive Bayes in R language"
author: "Marcos J Ribeiro"
date: "07/05/2020"
fontsize: 9pt
output:
beamer_presentation:
theme: "AnnArbor"
colortheme: "dolphin"
fonttheme: "structurebold"
---
title: "Naive Bayes in R language"
author: "Marcos J Ribeiro"
institute: 'FEARP-USP'
date: "07/05/2020"
fontsize: 8pt
output:
beamer_presentation:
theme: "AnnArbor"
colortheme: "dolphin"
fonttheme: "structurebold"
slide_level: 2
---
library(tensorflow)
library(tseries)
library(timeSeries)
library(forecast)   # auto.arima
library(quantmod)
library(fGarch)
library(rugarch)
#---- Get data
ibov = getSymbols('^BVSP', src='yahoo',
from= '1999-12-01',
to = '2020-04-01',
#periodicity = "monthly",    # IBOV mensal
auto.assign = F)[,4]
#----- returns
ret = diff(log(ibov))
colnames(ret) = c('ret')
ret = ret[is.na(ret)==F]  # Drop na to work
#---- GARCH Model
spec1 = ugarchspec(variance.model=list(model="fGARCH",
garchOrder=c(1,1), submodel='TGARCH'),
mean.model=list(armaOrder=c(0,0), include.mean=TRUE, archm=T),
distribution.model="norm")
garch2 = ugarchfit(spec = spec1, data= ret)
garch2
ts.plot(sigma(garch2))
plot(ret**2)
windows()
for(i in 1:(length(ret)-1)){
plot(as.vector( ret[1:(1+i)]), col='blue')
}
library(vars)
x = rnorm(1000)
y = rnorm(1000)
vmat = as.matrix(cbind(y, x))
vmat
head(vmat)
tail(vmat)
vfit = VAR(vmat)
summary(vfit)
irf(vfit)
plot(irf(vfit))
summary(vfit)
vfit
vfit = VAR(vmat, p=2)
summary(vfit)
curve(x)
curve(x)
curve(dnorm(x))
curve(dnorm(k, mean = 0, sd=1))
call(x)
N <- 40
x1 <- 10
x2 <- 20
b1 <- 100
b2 <- 10
mu <- 0
sig2e <- 2500
sde <- sqrt(sig2e)
yhat1 <- b1+b2*x1
yhat2 <- b1+b2*x2
curve(dnorm(x, mean=yhat1, sd=sde), 0, 500, col="blue")
curve(dnorm(k, mean=yhat1, sd=sde), 0, 500, col="blue")
rm(x)
N <- 40
x1 <- 10
x2 <- 20
b1 <- 100
b2 <- 10
mu <- 0
sig2e <- 2500
sde <- sqrt(sig2e)
yhat1 <- b1+b2*x1
yhat2 <- b1+b2*x2
curve(dnorm(x, mean=yhat1, sd=sde), 0, 500, col="blue")
curve((k))
curve((x))
curve((x^2))
curve((x^3))
curve((x^3), xlim = c(-1,1))
curve((x), xlim = c(-1,1))
plot(y)
curve((x), xlim = c(-1,1))
plot(rnorm(30), col='lightblue')
curve((x), xlim = c(-1,1), add=T)
curve((x), xlim = c(-1,1), add=T)
curve((x), xlim = c(-1,1))
plot(rnorm(30), col='lightblue')
plot(rnorm(30,0,1), col='lightblue')
plot(rnorm(30,0,1), col='lightblue')
curve((x), add=T)
plot(rnorm(30,0,1), col='lightblue')
curve((x^2), add=T)
curve((x+2), add=T)
curve((x+2X), add=T)
curve((x+2x), add=T)
curve((x+2*x), add=T)
curve((x+2*x), add=T)
plot(rnorm(30,0,1), col='lightblue')
curve((x+2*x), add=T)
curve((2*x+2*x), add=T)
curve((0.8*x+2*x), add=T)
curve((0.01x), add=T)
curve((0.01*x), add=T)
curve((0.1*x), add=T)
plot(abs(rnorm(30,0,1)), col='lightblue')
curve((0.1*x), add=T)
plot(abs(rnorm(30,0,1)), col='gray')
curve((0.1*x), add=T)
plot(abs(rnorm(30,0,1)), col='gray', lwd=19)
curve((0.1*x), add=T)
plot(abs(rnorm(30,0,1)), col='gray', lwd=19, size=3)
plot(abs(rnorm(30,0,1)), col='gray', lwd=19)
curve((0.1*x), add=T)
plot(abs(rnorm(30,0,1)), col='gray', lwd=19)
curve((0.1*x), add=T, col='red')
curve(dnorm(x))
curve(dnorm(x), xlim=c(-1,1))
curve(dnorm(x), xlim=c(-3,3))
curve(dnorm(x), xlim=c(-4,4))
curve(dnorm(x), xlim=c(-6,6))
curve(dnorm(x), xlim=c(-8,8))
write.csv(ret, 'ret')
write.table(ret, 'ret')
write.xlsx(ret, 'ret')
library(xlsx)
write.xlsx(ret, 'ret')
write.xlsx(ret, 'c:/ret.xlsx')
write.xlsx(ret,"C:/Users/user/Documents/ret.xlsx")
spec2 = ugarchspec(variance.model=list(model="sGARCH",
garchOrder=c(1,1)),
mean.model=list(armaOrder=c(0,0), include.mean=TRUE),
distribution.model="norm")
garch3 = ugarchfit(spec = spec2, data= ret)
garch3
spec1 = ugarchspec(variance.model=list(model="fGARCH",
garchOrder=c(1,1), submodel='TGARCH'),
mean.model=list(armaOrder=c(0,0), include.mean=TRUE, archm=T),
distribution.model="norm")
garch2 = ugarchfit(spec = spec1, data= ret)
garch2
sd(ret)
library(sn)
curve(dsn(x))
curve(dsn(x), ylim=c(-8,8))
curve(dsn(x), ylim=c(0,8))
curve(dsn(x, xi = 2), ylim=c(0,8))
curve(dsn(x, xi = 2, omega = 0.2, alpha = 0.22), ylim=c(0,8))
curve(dsn(x, xi = 2, omega = 0.2, alpha = 0.22))
curve(dsn(x, xi = 22, omega = 0.2, alpha = 0.22))
curve(dsn(x, omega = 0.2, alpha = 0.22))
curve(dsn(x, omega = 3, alpha = 0.22))
curve(dsn(x, omega = 8, alpha = 0.22))
curve(dsn(x, omega = 8, alpha = 0.22), , ylim=c(0,8))
curve(dsn(x, omega = 8, alpha = 0.22), , ylim=c(-8,8))
curve(dsn(x, omega = 8, alpha = 0.22), , ylim=c(0,8))
curve(dsn(x, omega = 8, alpha = 0.22), , ylim=c(0,0.8))
curve(dsn(x, omega = 8, alpha = 0.22))
curve(dsn(x, omega = 0.11, alpha = 0.22))
curve(dsn(x, omega = 0.21, alpha = 0.22))
curve(dsn(x, omega = 0.41, alpha = 0.22))
curve(dsn(x, omega = 0.1, alpha = 0.22))
curve(dsn(x, omega = 0.1, alpha = 2))
curve(dsn(x, omega = 0.1, alpha = 10))
curve(dsn(x, omega = 0.1, alpha = 100))
curve(dsn(x, omega = 0.1, alpha = 0.011))
curve(dst(x, omega = 0.1, alpha = 0.011))
curve(dst(x, omega = 1, alpha = 0.011))
curve(dst(x, omega = 1, alpha = 0.11))
curve(dst(x, omega = 1, alpha = 11))
curve(dst(x, omega = 0.9, alpha = 11))
curve(dst(x, omega = 0.11, alpha = 11))
curve(dst(x, omega = 0.11, alpha = 0.11))
rst(x, omega = 0.11, alpha = 0.11))
rst(100, omega = 0.11, alpha = 0.11))
rst(100, omega = 0.11, alpha = 0.11)
rst(100, omega = 0.2, alpha = 0.11, xi = 2)
rst(100, omega = 0.2, alpha = 0.11, xi = 0)
rst(100, omega = 0.2, alpha = 0.11, xi = 0, nu = 2)
setwd("D:/Git projects/Finance/Finance_R")
#--- Libraries
library(tseries)
library(timeSeries)
library(forecast)   # auto.arima
library(quantmod)
library(fGarch)
library(rugarch)
#---- Get data
ibov = getSymbols('^BVSP', src='yahoo',
from= '1999-12-01',
to = '2020-04-01',
#periodicity = "monthly",    # IBOV mensal
auto.assign = F)[,4]
#----- returns
ret = diff(log(ibov))
colnames(ret) = c('ret')
ret = ret[is.na(ret)==F]  # Drop na to work
#---- GARCH Model
spec1 = ugarchspec(variance.model=list(model="fGARCH",
garchOrder=c(1,1), submodel='TGARCH'),
mean.model=list(armaOrder=c(0,0), include.mean=TRUE, archm=T),
distribution.model="norm")
garch2 = ugarchfit(spec = spec1, data= ret)
garch2
spec1 = ugarchspec(variance.model=list(model="sGARCH",
garchOrder=c(1,1)),
mean.model=list(armaOrder=c(0,0), include.mean=TRUE, archm=T),
distribution.model="norm")
garch2 = ugarchfit(spec = spec1, data= ret)
garch2
spec1 = ugarchspec(variance.model=list(model="sGARCH",
garchOrder=c(1,1)),
mean.model=list(armaOrder=c(1,0), include.mean=TRUE, archm=T),
distribution.model="norm")
garch2 = ugarchfit(spec = spec1, data= ret)
garch2
spec1 = ugarchspec(variance.model=list(model="sGARCH",
garchOrder=c(1,1)),
mean.model=list(armaOrder=c(0,0), include.mean=TRUE),
distribution.model="norm")
garch2 = ugarchfit(spec = spec1, data= ret)
garch2
spec1 = ugarchspec(variance.model=list(model="sGARCH",
garchOrder=c(1,1)),
mean.model=list(armaOrder=c(0,0), include.mean=TRUE, archm=T),
distribution.model="norm")
garch2 = ugarchfit(spec = spec1, data= ret)
garch2
garch2
spec1 = ugarchspec(variance.model=list(model="sGARCH",
garchOrder=c(1,1), variance.targeting=T),
mean.model=list(armaOrder=c(0,0), include.mean=TRUE, archm=T),
distribution.model="norm")
garch2 = ugarchfit(spec = spec1, data= ret)
garch2
spec1 = ugarchspec(variance.model=list(model="sGARCH",
garchOrder=c(1,1)),
mean.model=list(armaOrder=c(0,0), archm=T),
distribution.model="norm")
garch2 = ugarchfit(spec = spec1, data= ret)
garch2
spec1 = ugarchspec(variance.model=list(model="sGARCH",
garchOrder=c(1,1)),
mean.model=list(armaOrder=c(0,0), archm=T),
fixed.pars=list(mu=0),
distribution.model="norm")
garch2 = ugarchfit(spec = spec1, data= ret)
garch2
