s_cal = step(ent[i, ]%*%pes)
print(s_cal)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
print(e_t)
}
}
}
print('Os pesos são', pes)
}
neural()
print('pesos', pes)
print('pesos' pes)
print('pesos', 3)
cat('pesos', 3)
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in 1:length(s)){
s_cal = step(ent[i, ]%*%pes)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
print(e_t)
}
}
}
cat('Os pesos são', pes)
}
neural()
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in 1:length(s)){
s_cal = step(ent[i, ]%*%pes)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
}
}
}
cat('Os pesos são':, pes)
}
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in 1:length(s)){
s_cal = step(ent[i, ]%*%pes)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
print(e_t)
}
}
}
cat('Os pesos são':, pes)
}
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in 1:length(s)){
s_cal = step(ent[i, ]%*%pes)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
}
}
}
cat('Os pesos são:', pes)
}
neural()
#***************************************************************************
#                          Neural Network
#****************************************************************************
e1 = c(0, 0)
e2 = c(0, 1)
e3 = c(1, 0)
e4 = c(1, 1)
ent = rbind(e1, e2, e3, e4)
pes = c(0, 0)
s = c(0 , 0, 0, 1)
step = function(soma){
if (soma>=1) {
return(1)
}else{
return(0)
}
}
#### Neural network
neural = function(apr){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in 1:length(s)){
s_cal = step(ent[i, ]%*%pes)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
}
}
}
cat('Os pesos são:', pes)
}
neural(0.1)
neural(0.2)
neural(0.3)
neural(1)
neural(0.2)
neural(0.1)
121 - 74
47*12.7
11.44*60 + 12.35*61 - 47*12.7 +74*12.55
-11.44*60 - 12.35*61 + 47*12.7 + 74*12.55
-8.39 *99 + 8.49*99
-7.94*100 + 8.12*100
-8.50*100 + 9.3*100
-17.79*6 + 19.5*6
85+85+9.9+18+10.26
-8.12*100+8.78*100
install.packages(ctv)
install.packages('ctv')
install.packages('moments')
x1 = c(2, 1, 5, 7, 8, 0, 2, 1)
x1 = c(2, 1, 5, 7, 8, 0, 2, 1)
l = 0.5
x = cbind(x1, x2)
x = cbind(x1, x2)
x2 = c(11, 2, 4, 5, 78, 1, 2, 9)
x2 = c(11, 2, 4, 5, 78, 1, 2, 9)
x2 = c(11, 2, 4, 5, 78, 1, 2, 9)
x = cbind(x1, x2)
l = 0.5
y = c(1, 5, 2, 3, 7, 32, 2, 0)
b = t(t(x)%*%x)%*%t(x)%*%
b = t(t(x)%*%x)%*%t(x)%*%y
b = t(t(x)%*%x)%*%t(x)%*%y
b
b = inv(t(x)%*%x)%*%t(x)%*%y
install.packages("matlib")
library(matlib)
b = inv(t(x)%*%x)%*%t(x)%*%y
b
b = inv(t(x)%*%x + l )%*%t(x)%*%y
b
b = inv(t(x)%*%x + 1000 )%*%t(x)%*%y
b
reg = lm(y ~x1 + x2)
summary(reg)
b = inv(t(x)%*%x)%*%t(x)%*%y
b
reg = lm(y ~x1 + x2 - 1)
summary(reg)
b
137-133.89
133.189-138.5
-133.189+138.5
(-133.189+138.5)*5
(-133.189+138.99)*5
(16-4.8)/4.8
4.8/16
0.7*16
16-11.2
4.8*0.7
4.8*1.7
16/4.8
25.5/669.45
100*(25.5/669.45)
install.packages(sn)
install.packages('sn')
---
title: "Untitled"
output: html_document
---
---
title: "Untitled"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## R Markdown
This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.
When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:
```{r cars}
summary(cars)
```
## Including Plots
You can also embed plots, for example:
```{r pressure, echo=FALSE}
plot(pressure)
```
Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
plot(pressure)
plot(pressure)
```{r cars}
```{r cars}
library(tseries)
library(timeSeries)
library(forecast)   # auto.arima
library(tseries)
library(timeSeries)
library(forecast)   # auto.arima
library(tseries)
library(timeSeries)
#library(forecast)   # auto.arima
library(quantmod)
library(fGarch)
library(mFilter)
library(GetBCBData)   # get Bacen data
ibov = getSymbols('^BVSP', src='yahoo', from= '2007-01-01', auto.assign = F)[,4]
colnames(ibov)= c('ibov')
ibov = ibov[is.na(ibov)==F]   # elimina os na's da amostra
ibov = ibov[is.na(ibov)==F]   # elimina os na's da amostra
ibov = ibov[is.na(ibov)==F]   # elimina os na's da amostra
ibov = ibov[is.na(ibov)==F]   # elimina os na's da amostra
ibov = ibov[is.na(ibov)==F]   # elimina os na's da amostra
ibov = ibov[is.na(ibov)==F]   # elimina os na's da amostra
ibov = ibov[is.na(ibov)==F]   # elimina os na's da amostra
head(ibov)
plot(ibov)
ret = diff(log(ibov))
colnames(ret) = c('ret')
ret = ret[is.na(ret)==F]  # Drop na to work
par(mfrow=c(2,1))
plot(ret)
acf(ret)   # There isn't autocorrelation in returns. So isn't possible predict ret
par(mfrow=c(1,2))
plot(ret)
acf(ret)   # There isn't autocorrelation in returns. So isn't possible predict ret
par(mfrow=c(1,2))
plot(ret, main='Evolução dos retornos do IBOV')
acf(ret)   # There isn't autocorrelation in returns. So isn't possible predict ret
par(mfrow=c(2,1))
plot(ret^2)
acf(ret^2)   # In squares of returns there is autocorrelation
par(mfrow=c(1,2))
plot(ret^2, main= 'Evolução do quadrado dos retornos do IBOV')
acf(ret^2)   # In squares of returns there is autocorrelation
basicStats(ibov)
basicStats(ret)
basicStats(ibov)
basicStats(ret)
for (i in 1:5) {
print(ArchTest(x = ret, lags = i))
}
library(tseries)
library(timeSeries)
library(forecast)   # auto.arima
library(quantmod)
library(fGarch)
library(mFilter)
library(GetBCBData)   # get Bacen data
for (i in 1:5) {
print(ArchTest(x = ret, lags = i))
}
library(forecast)   # auto.arima
install.packages(forecast)
install.packages('forecast')
library(forecast)   # auto.arima
install.packages('glue')
library(glue)
library(forecast)   # auto.arima
library(fGarch)
library(mFilter)
library(GetBCBData)   # get Bacen data
library(quantmod)
library(tseries)
library(timeSeries)
for (i in 1:5) {
print(ArchTest(x = ret, lags = i))
}
for (i in 1:5) {
print(archTest(x = ret, lags = i))
}
for (i in 1:5) {
print(ArchTest(x = ret, lags = i))
}
for (i in 1:5) {
print(arch.test(x = ret, lags = i))
}
garch1 = garchFit(formula = ~garch(1,1),
data = ret)
garch1 = garchFit(formula = ~garch(1,1),
data = ret)
garch1 = garchFit(formula = ~garch(1,1),data = ret)
summary(garch1)
vol = garch1@sigma.t
vol = as.xts(vol, order.by = data)
vol = garch1@sigma.t
vol = as.xts(vol, order.by = data)
vol = garch1@sigma.t
vol = as.xts(vol, order.by = data)
data = index(ret)
vol = garch1@sigma.t
vol = as.xts(vol, order.by = data)
data = index(ret)
vol = garch1@sigma.t
vol = as.xts(vol, order.by = data)
par(mfrow=c(2, 2))
plot(ibov, main='Evolution of IBOV')
plot(ret, main='Evolution of IBOV returns')
plot(ret^2, main='Evolution of square of IBOV returns')
plot(vol, main= 'Volatility of IBOV returns by GARCH(1,1)')
library(rugarch)
spec = ugarchspec()
spec
ugarchfit(variance.model = )
#ugarchfit(variance.model = )
spec1 = ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(1,1)),
mean.model=list(armaOrder=c(1,0), include.mean=TRUE),
distribution.model="norm")
garch2 = ugarchfit(spec = spec1, data= ret)
garch2
pred2 = ugarchforecast(garch2, n.ahead = 5)
plot(pred2, type='l')
pred2 = ugarchforecast(garch2, n.ahead = 5)
pred2 = pred2@forecast$sigmaFor
plot(pred2, type='l')
pred2 = ugarchforecast(garch2, n.ahead = 5)
plot(pred2, type='l')
ibov = getSymbols('^BVSP', src='yahoo', from= '2007-01-01', auto.assign = F)[,4]
colnames(ibov)= c('ibov')
ibov = ibov[is.na(ibov)==F]   # elimina os na's da amostra
head(ibov)
head(ibov)
par(mfrow=c(3,1))
plot(ret^2)
acf(ret^2)   # In squares of returns there is autocorrelation
pacf(ret^2)
plot(ret, main='Evolution of IBOV returns')
plot(ret, main='Evolution of IBOV returns')
plot(ibov, main='Evolution of \n IBOV')
garch1 = garchFit(formula = ~garch(1,1),
data = ret)
garch1 = garchFit(formula = ~garch(1,1),
data = ret);
quiet(garch1 = garchFit(formula = ~garch(1,1),
data = ret))
library(ddpcr)
install.packages(ddpcr)
install.packages('ddpcr')
library(ddpcr)
quiet(garch1 = garchFit(formula = ~garch(1,1),
data = ret))
garch1 = quiet(garchFit(formula = ~garch(1,1),
data = ret))
garch1
garch1 = garchFit(formula = ~garch(1,1),
data = ret)
knitr::opts_chunk$set(echo = TRUE)
library(tseries)
library(timeSeries)
library(quantmod)
library(fGarch)
library(mFilter)
ibov = getSymbols('^BVSP', src='yahoo', from= '2007-01-01', auto.assign = F)[,4]
colnames(ibov)= c('ibov')
ibov = ibov[is.na(ibov)==F]   # elimina os na's da amostra
head(ibov)
plot(ibov)
ret = diff(log(ibov))
colnames(ret) = c('ret')
ret = ret[is.na(ret)==F]  # Drop na to work
par(mfrow=c(2,1))
plot(ret, main='Evolução dos retornos do IBOV')
acf(ret)   # There isn't autocorrelation in returns. So isn't possible predict ret
par(mfrow=c(2,1))
plot(ret^2, main= 'Evolução do quadrado dos retornos do IBOV')
acf(ret^2)   # In squares of returns there is autocorrelation
basicStats(ret)
basicStats(ibov)
garch1 = garchFit(formula = ~garch(1,1),data = ret)
summary(garch1)
data = index(ret)
vol = garch1@sigma.t
vol = as.xts(vol, order.by = data)
par(mfrow=c(2, 2))
plot(ibov, main='Evolution of IBOV')
plot(ret, main='Evolution of IBOV returns')
plot(ret^2, main='Evolution of square \n of IBOV returns')
plot(vol, main= 'Volatility of IBOV \n returns by GARCH(1,1)')
9.37-8.48
50*(9.37-8.48)
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2000-01-01', auto.assign = F)[,4]
library(tseries)
library(timeSeries)
library(quantmod)
library(fGarch)
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2000-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2010-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2015-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VIX', src='yahoo', from= '2015-01-01', auto.assign = F)[,4]
View(vxewz)
vIX = getSymbols('^VIX', src='yahoo', from= '2000-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2000-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2010-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2011-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2011-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2011-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2011-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2011-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2012-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2013-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2014-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2012-01-01', auto.assign = F)[,4]
View(vxewz)
vx = getSymbols('^VXEWZ', src='yahoo', from= '2012-01-01', auto.assign = F)[,4]
warnings()
vx = getSymbols('^VXEWZ', src='yahoo', from= '2015-01-01', auto.assign = F)[,4]
vx = getSymbols('^VXEWZ', src='yahoo', from= '2015-01-01', auto.assign = F)[,4]
vix = getSymbols('^VIX', src='yahoo', from= '2015-01-01', auto.assign = F)[,4]
rm(vIX)
library(quantmod)
plot(vx)
plot(vxewz)
basicStats(vxewz)
basicStats(vix)
par(mfrow=c(2,1))
plot(vxewz)
plot(vix)
plot(vix)
plot(vxewz)
par(mfrow=c(1,1))
plot(vix)
library(tseries)
library(timeSeries)
library(quantmod)
library(fGarch)
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2015-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2015-01-01')[,4]
vix = getSymbols('^VIX', src='yahoo', from= '2015-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2015-01-01')[,4]
plot(vix)
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2012-01-01')[,4]
setwd("D:/DOUTORADO/Finance Econometry/Finance_aplications")
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2015-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2015-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2015-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2015-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2015-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2015-01-01', auto.assign = F)[,4]
vxewz = getSymbols('^VXEWZ', src='yahoo', from= '2020-01-01', auto.assign = F)[,4]
vwz = getSymbols('^VXEWZ', src='yahoo', from= '2020-01-01', auto.assign = F)[,4]
vwz = getSymbols('^VXEWZ', src='yahoo', from= '2020-01-01', auto.assign = F)[,4]
vwz = getSymbols('^VXEWZ', src='yahoo', from= '2020-01-01', auto.assign = F)[,4]
vwz = getSymbols('^VXEWZ', src='yahoo', from= '2020-01-01', auto.assign = F)[,4]
vwz = getSymbols('^VXEWZ', src='yahoo', from= '2020-01-01', auto.assign = F)[,4]
vwz = getSymbols('^VXEWZ', src='yahoo', from= '2020-01-01', auto.assign = F)[,4]
vwz = getSymbols('^VXEWZ', src='yahoo', from= '2020-01-01', auto.assign = F)[,4]
vwz = getSymbols('^VXEWZ', src='google', from= '2020-01-01', auto.assign = F)[,4]
vwz = getSymbols('^VXEWZ', src='https://br.investing.com/indices/cboe-brazil-etf-volatility-historical-data', from= '2020-01-01', auto.assign = F)[,4]
vwz = getSymbols('^VXEWZ', src='yahoo', from= '2020-01-01', auto.assign = F)[,4]
vwz = read.excel()
vwz = read.csv('vxewz', sep=",")
setwd("D:/DOUTORADO/Finance Econometry/Finance_aplications")
vwz = read.csv('vxewz.csv', sep=",")
setwd("D:/Git projects/Finance/Finance_R")
vwz = read.csv('vxewz.csv', sep=",")
View(vwz)
sort(vwz$ï..Data)
View(vwz)
vwz = read.csv('vxewz.csv', sep=",")
View(vwz)
vwz = read.csv('vxewz.csv', sep=",")
View(vwz)
vwz = read.csv('vxewz.csv')
View(vwz)
rm(vxz)
rm(vwz)
vwz = read.csv('vxewz.csv')
View(vwz)
View(vix)
View(vix)
vwz = read.csv('vxewz.csv')
View(vwz)
vwz = read.csv('vxewz.csv', sep=',')
View(vwz)
vwz = read.csv('vxewz.csv', sep=',', header = T)
View(vwz)
vx = read.csv(choose.files())
View(vx)
vwz = read.csv('vxewz.csv', sep=',', header = T)
View(vwz)
vwz = read.csv('vxewz.csv', sep=';', header = T)
View(vwz)
rm(vx)
basicStats(vwz)
summary(vwz)
plot(vwz)
View(vwz)
View(vwz)
vwz = read.csv('vxewz.csv', sep=';', header = T)
summary(vwz)
vwz$ï..data
vwz$data
as.date(vwz$data)
date(vwz$data)
as.date(vwz$data)
